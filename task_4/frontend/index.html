<!doctype html>
<html lang="en-GB">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Todo Scheduler</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <style>
      :root{
        --bg:#0f1724;
        --card:#0b1220;
        --muted:#9aa4b2;
        --accent:#6ee7b7;
        --accent-2:#60a5fa;
        --glass: rgba(255,255,255,0.04);
        --radius:14px;
      }
      *{box-sizing:border-box}
      body{
        margin:0; min-height:100vh; font-family:'Inter',system-ui,Segoe UI,Roboto,Arial;
        background: radial-gradient(1000px 600px at 10% 10%, rgba(96,165,250,0.08), transparent),
                    linear-gradient(180deg,#071025 0%, #071729 60%);
        color:#e6eef8; display:flex; align-items:flex-start; justify-content:center; padding:40px 16px;
      }
      /* Delete button hover: red glow */
      #delListBtn:hover{
        box-shadow: 0 6px 18px rgba(220,38,38,0.28);
        border-color: rgba(220,38,38,0.6);
        color: #ffdddd;
      }
      .wrap{width:100%;max-width:920px}
      header{display:flex;align-items:center;gap:16px;margin-bottom:18px}
      .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent-2));display:flex;align-items:center;justify-content:center;font-weight:700;color:#04263b}
      h1{font-family:'Poppins',sans-serif;margin:0;font-size:20px}
      p.lead{margin:0;color:var(--muted);font-size:13px}

      .grid{display:grid;grid-template-columns:1fr 360px;gap:20px;align-items:start}
      @media (max-width:900px){ .grid{grid-template-columns:1fr} }

      /* Card */
      .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:var(--radius);padding:18px;box-shadow:0 8px 30px rgba(2,6,23,0.6);}

      /* Form */
      form{display:grid;gap:12px}
      /* inputs/selects tuned for dark mode readability */
      input, textarea, select{
        background: rgba(255,255,255,0.02);
        border:1px solid rgba(255,255,255,0.06);
        color: #e6eef8;
        padding:10px;border-radius:10px;font-size:14px
      }
      input:focus, textarea:focus{outline:none;border-color:rgba(96,165,250,0.25);box-shadow:0 6px 20px rgba(96,165,250,0.06);color:#e6eef8}
      textarea{min-height:88px;resize:vertical}
      .form-row{display:flex;gap:8px}
      button.primary{background:linear-gradient(90deg,var(--accent),var(--accent-2));border:none;color:#04263b;padding:10px 12px;border-radius:10px;font-weight:600;cursor:pointer;transition:transform .12s ease, box-shadow .12s}
      button.primary:hover{transform:translateY(-3px);box-shadow:0 8px 30px rgba(96,165,250,0.16)}

      /* Styled select with custom arrow */
      select{appearance:none;-webkit-appearance:none;-moz-appearance:none;background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='12' height='8' viewBox='0 0 12 8'><path fill='%23e6eef8' d='M6 8L0 0h12z'/></svg>");background-repeat:no-repeat;background-position:right 12px center;padding-right:40px;cursor:pointer;background-color:rgba(11,18,32,0.6)}
      select:focus{outline:none;border-color:rgba(96,165,250,0.45);box-shadow:0 10px 30px rgba(96,165,250,0.08);color:#e6eef8}
      select:hover{border-color:rgba(255,255,255,0.08)}

      /* Prefer dark background for option list where supported */
      select option{background:var(--card);color:#e6eef8}

      /* Small responsive tweak to ensure the select fills form width */
      #scheduleType{width:100%;display:block}

      /* Tasks list */
      ul{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:12px}
      .task-card{display:block;padding:12px;border-radius:12px;background:linear-gradient(180deg, rgba(255,255,255,0.015), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);box-shadow:0 6px 18px rgba(2,6,23,0.5);overflow:hidden;position:relative;}
      .task-top{display:flex;justify-content:space-between;align-items:center;gap:12px}
      .task-title{font-weight:600;color:#f8fbff}
      .meta{color:var(--muted);font-size:12px;margin-top:6px}
      .notes{margin-top:8px;color:var(--muted);font-size:13px}
      .actions{margin-top:10px;display:flex;gap:8px}
      .chip{padding:6px 8px;border-radius:999px;font-size:12px;background:rgba(255,255,255,0.02);color:var(--muted)}

      /* Animations */
      @keyframes slideUpFade{from{opacity:0;transform:translateY(8px) scale(.995)}to{opacity:1;transform:none}}
      @keyframes pop{from{transform:scale(.98)}to{transform:scale(1)}}
      .task-card{animation:slideUpFade .42s cubic-bezier(.2,.9,.3,1) both;transform-origin:top center}
      .task-card.removing{animation:pop .18s ease both;opacity:0;transform:scale(.96);transition:opacity .22s}

      /* Completed task styling */
      .task-card.completed .task-title,
      .task-card.completed .notes,
      .task-card.completed .meta { text-decoration: line-through; opacity: 0.6 }
      .task-card.completed .chip{ background: rgba(255,255,255,0.02); color: var(--muted); }

      /* small helper */
      .empty{color:var(--muted);padding:20px;text-align:center}

      footer.note{margin-top:12px;color:var(--muted);font-size:12px;text-align:center}
      /* Confirmation modal + toast messages */
      #confirmModal{display:none;position:fixed;inset:0;align-items:center;justify-content:center;background:rgba(2,6,23,0.6);z-index:1200}
      #confirmModal .confirm-box{background:var(--card);padding:18px;border-radius:12px;min-width:300px;box-shadow:0 10px 40px rgba(2,6,23,0.6);color:#e6eef8}
      #confirmModal .confirm-message{margin-bottom:12px;color:var(--muted)}
      #confirmModal .confirm-actions{display:flex;gap:8px;justify-content:flex-end}
      #confirmModal .confirm-yes{background:linear-gradient(90deg,var(--accent),var(--accent-2));border:none;color:#04263b;padding:8px 10px;border-radius:8px;cursor:pointer}
      #confirmModal .confirm-no{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted);padding:8px 10px;border-radius:8px;cursor:pointer}

      #toastContainer{position:fixed;top:18px;right:18px;display:flex;flex-direction:column;gap:8px;z-index:1300}
      .toast{background:rgba(255,255,255,0.04);padding:10px 12px;border-radius:10px;color:#e6eef8;box-shadow:0 8px 30px rgba(2,6,23,0.5);opacity:1;transition:opacity .4s}
      .toast.error{background:linear-gradient(180deg, rgba(220,38,38,0.12), rgba(220,38,38,0.06));color:#ffdede}
      .toast.success{background:linear-gradient(180deg, rgba(34,197,94,0.08), rgba(34,197,94,0.04));color:#04263b}
    </style>
  </head>
  <body>
    <div class="wrap">
      <header>
        <div class="logo">TS</div>
        <div>
          <h1>Todo Scheduler</h1>
          <p class="lead">Schedule small tasks and the server will mark them done at the time.</p>
        </div>
      </header>

      <div class="grid">
        <section class="card">
          <form id="taskForm">
            <input name="title" placeholder="What do you want to do?" required />

            <div style="display:flex;gap:8px;align-items:center">
              <select id="listSelect" aria-label="Select list"></select>
              <button type="button" id="newListBtn" style="background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:6px 10px;border-radius:8px;cursor:pointer">+ New List</button>
              <button type="button" id="delListBtn" aria-label="Delete selected list" title="Delete list" style="background: rgba(220,38,38,0.03); border: 1px solid rgba(255,255,255,0.06); color: #ffdede; padding: 6px 10px; border-radius: 8px; cursor: pointer; font-weight:600">Delete List</button>

              <!-- inline new-list editor (hidden by default) -->
              <div id="newListInline" style="display:none;align-items:center;gap:6px;margin-left:6px">
                <input id="newListInput" placeholder="New list name" style="padding:6px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--muted);" />
                <button type="button" id="newListSaveBtn" style="padding:6px 8px;border-radius:8px;background:var(--accent);border:0;color:#04263b;cursor:pointer">Save</button>
                <button type="button" id="newListCancelBtn" style="padding:6px 8px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);cursor:pointer">Cancel</button>
              </div>
            </div>

            <label style="font-size:13px;color:var(--muted);margin-top:6px">Schedule type</label>
            <select name="scheduleType" id="scheduleType">
              <option value="once">One time</option>
              <option value="daily">Daily</option>
              <option value="weekly">Weekly</option>
              <option value="interval">Every X minutes</option>
              <option value="cron">Cron expression (advanced)</option>
            </select>

            <div id="scheduleControls">
              <div data-for="once" class="control-block">
                <div class="form-row">
                  <input type="text" id="onceDate" name="onceDate" style="max-width:160px" placeholder="dd/mm/yyyy" />
                  <input type="time" name="onceTime" />
                </div>
              </div>

              <div data-for="daily" class="control-block" style="display:none">
                <label class="meta">Time of day</label>
                <input type="time" name="dailyTime" />
              </div>

              <div data-for="weekly" class="control-block" style="display:none">
                <label class="meta">Time</label>
                <input type="time" name="weeklyTime" />
                <div style="margin-top:8px;display:flex;gap:6px;flex-wrap:wrap">
                  <label><input type="checkbox" name="weekday" value="0" /> Sun</label>
                  <label><input type="checkbox" name="weekday" value="1" /> Mon</label>
                  <label><input type="checkbox" name="weekday" value="2" /> Tue</label>
                  <label><input type="checkbox" name="weekday" value="3" /> Wed</label>
                  <label><input type="checkbox" name="weekday" value="4" /> Thu</label>
                  <label><input type="checkbox" name="weekday" value="5" /> Fri</label>
                  <label><input type="checkbox" name="weekday" value="6" /> Sat</label>
                </div>
              </div>

              <div data-for="interval" class="control-block" style="display:none">
                <label class="meta">Interval (minutes)</label>
                <input type="number" name="intervalMinutes" min="1" placeholder="e.g. 15" />
              </div>

              <div data-for="cron" class="control-block" style="display:none">
                <label class="meta">Cron (seconds minutes hours day month dayOfWeek)</label>
                <input name="cronExpr" placeholder="e.g. 0 30 9 * * 1-5" />
              </div>
            </div>

            <textarea name="notes" placeholder="Notes (optional)"></textarea>
            <div style="display:flex;justify-content:space-between;align-items:center">
              <div style="color:var(--muted);font-size:13px">Tip: choose a schedule type</div>
              <button class="primary" type="submit">Schedule Task</button>
            </div>
          </form>
          <footer class="note">Tasks are persisted to the backend and will be marked done when triggered.</footer>
        </section>

        <aside class="card">
          <h3 style="margin:0 0 12px 0">Tasks</h3>
          <ul id="tasks" aria-live="polite"></ul>
        </aside>
      </div>
    </div>

    <!-- Inline confirmation modal -->
    <div id="confirmModal" role="dialog" aria-modal="true">
      <div class="confirm-box">
        <div class="confirm-message">Are you sure?</div>
        <div class="confirm-actions">
          <button class="confirm-no">Cancel</button>
          <button class="confirm-yes">Yes</button>
        </div>
      </div>
    </div>

    <!-- Toast container -->
    <div id="toastContainer" aria-live="polite" aria-atomic="true"></div>

    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script>
      const API = 'http://localhost:3000';

      // In-page UI helpers: confirm modal and toast messages
      function showToast(message, type='info'){
        try{
          const container = document.getElementById('toastContainer');
          const t = document.createElement('div'); t.className = 'toast ' + (type === 'error' ? 'error' : (type === 'success' ? 'success' : ''));
          t.textContent = message;
          container.appendChild(t);
          setTimeout(()=>{ t.style.opacity = '0'; setTimeout(()=> t.remove(), 400); }, 3500);
        }catch(e){ console.log('toast failed', e); }
      }

      function showConfirm(message){
        return new Promise(resolve => {
          const modal = document.getElementById('confirmModal');
          const msg = modal.querySelector('.confirm-message');
          const yes = modal.querySelector('.confirm-yes');
          const no = modal.querySelector('.confirm-no');
          msg.textContent = message;
          modal.style.display = 'flex';
          function cleanup(answer){
            modal.style.display = 'none';
            yes.removeEventListener('click', onYes);
            no.removeEventListener('click', onNo);
            resolve(answer);
          }
          function onYes(){ cleanup(true); }
          function onNo(){ cleanup(false); }
          yes.addEventListener('click', onYes);
          no.addEventListener('click', onNo);
        });
      }

      let activeListId = 'default';

      async function fetchLists(){
        try{
          const res = await fetch(API + '/lists');
          return res.json();
        }catch(e){ console.error('Failed to fetch lists', e); return []; }
      }

      async function fetchTasks(){
        try{
          const url = API + '/tasks' + (activeListId ? ('?listId=' + encodeURIComponent(activeListId)) : '');
          const res = await fetch(url);
          return res.json();
        }catch(e){
          console.error('Failed to fetch tasks', e);
          return [];
        }
      }

      function escapeHtml(s){ return (s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

      function formatDate(iso){
        try{ return new Date(iso).toLocaleString(); }catch(e){ return iso }
      }

      function describeSchedule(s){
        if(!s) return 'one-time';
        if(s.type === 'once') return `once at ${formatDate(s.time)}`;
        if(s.type === 'daily') return `daily at ${s.time}`;
        if(s.type === 'weekly') return `weekly at ${s.time} on ${Array.isArray(s.weekdays) ? s.weekdays.join(',') : 'any'}`;
        if(s.type === 'interval') return `every ${s.intervalSeconds ? Math.round(s.intervalSeconds/60) : '?'} minutes`;
        if(s.type === 'cron') return `cron: ${s.cron}`;
        return JSON.stringify(s);
      }

      function createTaskElement(t, index){
        const li = document.createElement('li');
        li.className = 'task-card';
        li.style.animationDelay = (index * 40) + 'ms';

        const executed = t.executedAt ? ` • executed ${formatDate(t.executedAt)}` : '';
        const schedDesc = describeSchedule(t.schedule || (t.time ? {type:'once', time:t.time} : null));

        li.innerHTML = `
          <div class="task-top">
            <div>
              <div class="task-title">${escapeHtml(t.title)}</div>
              <div class="meta">${formatDate(t.time || t.createdAt)} • <span class="chip">${t.status}</span>${executed}</div>
              <div class="meta" style="margin-top:6px;font-size:12px;color:var(--muted)">${escapeHtml(schedDesc)}</div>
            </div>
            <div style="text-align:right;display:flex;gap:8px;align-items:center">
              <button data-id="${t.id}" data-action="complete" title="Complete" style="background:transparent;border:0;color:var(--muted);cursor:pointer">✔</button>
              <button data-id="${t.id}" data-action="delete" title="Delete" style="background:transparent;border:0;color:var(--muted);cursor:pointer">✕</button>
            </div>
          </div>
          <div class="notes">${escapeHtml(t.notes || '')}</div>
        `;

        // mark completed styling
        if(t.status === 'done' || t.executedAt){
          li.classList.add('completed');
        }

        return li;
      }

      async function render(tasks){
        const ul = document.getElementById('tasks');
        ul.innerHTML = '';
        if(!tasks || tasks.length === 0){
          const empty = document.createElement('div'); empty.className='empty'; empty.textContent = 'No tasks yet — schedule one!';
          ul.appendChild(empty); return;
        }

        tasks.sort((a,b)=> new Date(a.time || a.createdAt) - new Date(b.time || b.createdAt));
        tasks.forEach((t,i)=> ul.appendChild(createTaskElement(t,i)));
      }

      // Notification helpers: request permission and show a notification (with toast fallback)
      const NOTIFY_BEFORE_MS = 5 * 60 * 1000; // notify 5 minutes before
      const _notifiedSet = new Set(); // keys: `${taskId}:${timestamp}` to avoid duplicates

      async function requestNotificationPermission(){
        try{
          if(!('Notification' in window)){
            showToast('Browser notifications are not supported in this browser', 'error');
            return false;
          }
          if(Notification.permission === 'granted') return true;
          if(Notification.permission === 'denied'){
            showToast('Notifications are blocked in your browser. Enable them to get reminders.', 'error');
            return false;
          }
          const p = await Notification.requestPermission();
          return p === 'granted';
        }catch(e){ console.error('notification permission failed', e); return false; }
      }

      function showTaskNotification(task, when){
        const title = `Upcoming: ${task.title}`;
        const timeText = when ? new Date(when).toLocaleTimeString() : '';
        const body = `Due at ${timeText}${task.notes ? ' — ' + task.notes : ''}`;
        try{
          if('Notification' in window && Notification.permission === 'granted'){
            const notif = new Notification(title, { body, tag: `task-${task.id}-${when}`, renotify: false });
            // optional click handler to focus the page
            notif.onclick = () => { try{ window.focus(); }catch(e){} };
          }
        }catch(e){ console.error('show notification error', e); }
        // always show an in-page toast as fallback/extra UX
        showToast(`${title} — ${timeText}`, 'info');
      }

      function computeNextOccurrence(task){
        const now = new Date();
        const s = task.schedule || null;
        try{
          if(s && s.type === 'once'){
            const t = task.time || s.time; if(!t) return null; const d = new Date(t); if(isNaN(d)) return null; return d;
          }
          if(task.time && !s){ const d = new Date(task.time); if(!isNaN(d)) return d; }
          if(s && s.type === 'daily'){
            // s.time is like "HH:MM"
            const [hh,mm] = (s.time || '').split(':').map(Number);
            if(isNaN(hh)) return null;
            const d = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hh, mm||0, 0);
            if(d <= now) d.setDate(d.getDate() + 1);
            return d;
          }
          if(s && s.type === 'weekly'){
            // s.weekdays = [0..6], s.time = "HH:MM"
            const days = Array.isArray(s.weekdays) && s.weekdays.length ? s.weekdays : [0,1,2,3,4,5,6];
            const [hh,mm] = (s.time || '').split(':').map(Number);
            const today = now.getDay();
            // find the next day in days including today if time not passed
            for(let offset=0; offset<14; offset++){
              const candDay = (today + offset) % 7;
              if(days.includes(candDay)){
                const candidate = new Date(now.getFullYear(), now.getMonth(), now.getDate() + offset, hh||0, mm||0, 0);
                if(candidate > now) return candidate;
              }
            }
            return null;
          }
          if(s && s.type === 'interval'){
            const seconds = Number(s.intervalSeconds || s.interval || 0);
            if(!(seconds > 0)) return null;
            // if task.executedAt present, next = executedAt + interval
            if(task.executedAt){ const d = new Date(task.executedAt); d.setSeconds(d.getSeconds() + seconds); if(d > now) return d; }
            // otherwise, use createdAt or time as a base, step forward until > now (cap iterations)
            let base = task.createdAt ? new Date(task.createdAt) : (task.time ? new Date(task.time) : null);
            if(!base || isNaN(base)) base = new Date();
            const maxSteps = 1000; let steps = 0;
            while(steps++ < maxSteps){ base = new Date(base.getTime() + seconds * 1000); if(base > now) return base; }
            return null;
          }
          // cron or unknown: skip computing on client
          return null;
        }catch(e){ console.error('computeNextOccurrence failed', e); return null; }
      }

      // Go through tasks and show notifications for any upcoming occurrence within NOTIFY_BEFORE_MS
      function scheduleUpcomingNotifications(tasks){
        try{
          if(!tasks || !tasks.length) return;
          const now = Date.now();
          for(const t of tasks){
            const next = computeNextOccurrence(t);
            if(!next) continue;
            const key = `${t.id}:${next.getTime()}`;
            const delta = next.getTime() - now;
            if(delta > 0 && delta <= NOTIFY_BEFORE_MS){
              if(!_notifiedSet.has(key)){
                _notifiedSet.add(key);
                showTaskNotification(t, next.getTime());
              }
            } else if(delta <= 0){
              // if we're past the occurrence, make sure we don't keep the stale key forever
              _notifiedSet.delete(key);
            }
          }
        }catch(e){ console.error('scheduleUpcomingNotifications failed', e); }
      }

      let __isRefreshing = false;
      async function refresh(){
        if(__isRefreshing) return; // avoid overlapping fetches
        __isRefreshing = true;
        try{
          const tasks = await fetchTasks();
          render(tasks);
          // schedule notifications for upcoming tasks (client-side check)
          scheduleUpcomingNotifications(tasks);
        }catch(e){ console.error('refresh failed', e); }
        finally{ __isRefreshing = false; }
      }

      // Ensure delete button state matches current selection
      function updateDeleteButtonState(){
        const delBtn = document.getElementById('delListBtn');
        if(!delBtn) return;
        const cannotDelete = !activeListId || activeListId === 'default';
        delBtn.disabled = !!cannotDelete;
        delBtn.title = cannotDelete ? 'Cannot delete default list' : 'Delete list';
        delBtn.style.opacity = cannotDelete ? '0.6' : '';
        delBtn.style.cursor = cannotDelete ? 'default' : 'pointer';
      }

      // soft-delete helpers (store hidden list IDs locally)
      function _getSoftDeleted(){
        try{ return JSON.parse(localStorage.getItem('ts.softDeleted') || '[]'); }catch(e){ return []; }
      }
      function _addSoftDeleted(id){
        if(!id) return;
        const arr = _getSoftDeleted();
        if(!arr.includes(id)){ arr.push(id); localStorage.setItem('ts.softDeleted', JSON.stringify(arr)); }
      }
      function _removeSoftDeleted(id){
        if(!id) return;
        const arr = _getSoftDeleted().filter(x=>x!==id);
        localStorage.setItem('ts.softDeleted', JSON.stringify(arr));
      }

      // load and render lists into selector
      async function loadLists(){
        let lists = await fetchLists();
        const soft = _getSoftDeleted();
        // filter out soft-deleted ids so they stay hidden in the UI
        lists = (lists || []).filter(l => !soft.includes(l.id));
        const sel = document.getElementById('listSelect');
        // ensure there's always a default list visible
        if(!lists.find(l => l.id === 'default')){
          lists.unshift({ id: 'default', name: 'General', createdAt: null });
        }
        sel.innerHTML = '';
        for(const l of lists){
          const opt = document.createElement('option'); opt.value = l.id; opt.textContent = l.name; sel.appendChild(opt);
        }
        // choose active or fallback to default
        if(!lists.find(x=>x.id === activeListId)) activeListId = lists[0] ? lists[0].id : 'default';
        try{ sel.value = activeListId; }catch(e){}
        updateDeleteButtonState();
      }

      document.getElementById('listSelect').addEventListener('change', (e)=>{ activeListId = e.target.value; updateDeleteButtonState(); refresh(); });
      // new list: show inline editor instead of prompt
      const newListBtn = document.getElementById('newListBtn');
      const newListInline = document.getElementById('newListInline');
      const newListInput = document.getElementById('newListInput');
      const newListSaveBtn = document.getElementById('newListSaveBtn');
      const newListCancelBtn = document.getElementById('newListCancelBtn');

      newListBtn.addEventListener('click', ()=>{
        const showing = newListInline.style.display === 'none' ? true : (newListInline.style.display !== 'none' ? false : true);
        // toggle: if we're going to show the inline editor, hide the button
        if(showing){
          newListInline.style.display = 'flex';
          newListBtn.style.display = 'none';
          newListInput.value = '';
          newListInput.focus();
        } else {
          newListInline.style.display = 'none';
          newListBtn.style.display = '';
        }
      });

      newListCancelBtn.addEventListener('click', ()=>{ newListInline.style.display = 'none'; newListBtn.style.display = ''; });

      async function createListFromInline(){
        const name = (newListInput.value || '').trim();
        if(!name){ showToast('List name cannot be empty', 'error'); return; }
        newListSaveBtn.disabled = true; newListSaveBtn.textContent = 'Saving...';
        try{
          const res = await fetch(API + '/lists', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name }) });
          if(!res.ok){ const body = await res.text().catch(()=>'<no body>'); console.error('create list failed', res.status, body); showToast('Failed to create list: ' + res.status + '\n' + body, 'error'); return; }
          const created = await res.json();
          activeListId = created.id;
          await loadLists();
          await refresh();
          newListInline.style.display = 'none';
          newListBtn.style.display = '';
          setTimeout(()=>{ const sel = document.getElementById('listSelect'); sel.value = activeListId; }, 40);
        }catch(err){ console.error('create list failed', err); alert('Failed to create list: ' + (err && err.message)); }
        finally{ newListSaveBtn.disabled = false; newListSaveBtn.textContent = 'Save'; }
      }

      newListSaveBtn.addEventListener('click', createListFromInline);
      newListInput.addEventListener('keyup', (e)=>{ if(e.key === 'Enter') createListFromInline(); if(e.key === 'Escape'){ newListInline.style.display = 'none'; newListBtn.style.display = ''; } });

      // removed newTaskBtn — creating tasks is done via the form directly

      
      document.getElementById('delListBtn').addEventListener('click', async ()=>{
        const delBtn = document.getElementById('delListBtn');
        if(!activeListId) return;
        if(activeListId === 'default'){ showToast('Cannot delete default list', 'error'); return; }
        const ok = await showConfirm('Delete this list and all its tasks?');
        if(!ok) return;

        // optimistic/offline-first removal: remove from UI immediately and remember locally
        const sel = document.getElementById('listSelect');
        const opt = sel.querySelector(`option[value="${activeListId}"]`);
        if(opt) opt.remove();
        // persist the soft-delete so the list stays hidden across reloads when backend is unreachable
        _addSoftDeleted(activeListId);

        // choose a safe active list (prefer 'default', otherwise first option)
        const hasDefault = !!sel.querySelector('option[value="default"]');
        if(hasDefault) activeListId = 'default';
        else if(sel.options.length) activeListId = sel.options[0].value;
        else activeListId = 'default';
        try{ sel.value = activeListId; }catch(e){}
        updateDeleteButtonState();
        refresh();

        // attempt to delete on server; if it fails we keep the soft-delete locally
        delBtn.disabled = true;
        const prevText = delBtn.textContent;
        delBtn.textContent = 'Deleting...';
        try{
          const res = await fetch(API + '/lists/' + encodeURIComponent(opt ? opt.value : activeListId), { method:'DELETE' });
          if(!res.ok){
            const txt = await res.text().catch(()=>'<no body>');
            console.error('delete list failed', res.status, txt);
            showToast('Failed to delete list on server: ' + res.status + '\n' + txt + '\nThe list remains hidden locally.', 'error');
            // keep soft-delete; reload lists filtered by soft-deletes
            await loadLists();
            return;
          }

          // server deleted successfully — remove from soft-deleted set so future fetches won't hide it
          _removeSoftDeleted(opt ? opt.value : activeListId);
          // reload lists from server to ensure UI matches server state
          await loadLists();
          refresh();
        }catch(err){
          console.error('delete list failed', err);
          showToast('Could not contact server. The list was removed locally and will remain hidden until server confirms deletion.', 'error');
        }finally{
          delBtn.disabled = false; delBtn.textContent = prevText;
        }
      });

      // submit: post and give quick feedback
      // show/hide schedule controls
      const scheduleTypeSel = document.getElementById('scheduleType');
      const controls = document.querySelectorAll('#scheduleControls [data-for]');
      function updateControls(){
        const v = scheduleTypeSel.value;
        controls.forEach(c=> c.style.display = c.getAttribute('data-for') === v ? '' : 'none');
      }
      scheduleTypeSel.addEventListener('change', updateControls);
      updateControls();

      // initialize Flatpickr for the one-time date input so display is dd/mm/yyyy
      if(window.flatpickr){
        window.onceDatePicker = flatpickr("input[name='onceDate']", {
          dateFormat: 'Y-m-d', // value format (ISO) so form submission can parse
          altInput: true,
          altFormat: 'd/m/Y', // displayed format
          allowInput: true
        });
      }

      document.getElementById('taskForm').addEventListener('submit', async (e)=>{
        e.preventDefault();
        const form = e.target;
        const fd = new FormData(form);
        const title = fd.get('title');
        const notes = fd.get('notes');
        const scheduleType = fd.get('scheduleType');
        if(!title) return;

        const payload = { title, notes };
        payload.listId = activeListId;

        if(scheduleType === 'once'){
          const date = fd.get('onceDate');
          const t = fd.get('onceTime');
          if(!date || !t) return alert('Please pick a date and time for a one-time task');
          // combine into an ISO timestamp (local)
          payload.time = new Date(date + 'T' + t).toISOString();
          payload.schedule = { type: 'once', time: payload.time };
        } else if(scheduleType === 'daily'){
          const t = fd.get('dailyTime');
          if(!t) return alert('Please select a time for the daily schedule');
          payload.schedule = { type: 'daily', time: t };
        } else if(scheduleType === 'weekly'){
          const t = fd.get('weeklyTime');
          const weekdays = [];
          form.querySelectorAll('input[name="weekday"]:checked').forEach(cb=> weekdays.push(Number(cb.value)));
          if(!t || weekdays.length === 0) return alert('Select time and at least one weekday');
          payload.schedule = { type: 'weekly', time: t, weekdays };
        } else if(scheduleType === 'interval'){
          const mins = Number(fd.get('intervalMinutes')) || 0;
          if(!(mins > 0)) return alert('Enter interval in minutes');
          payload.schedule = { type: 'interval', intervalSeconds: mins * 60 };
        } else if(scheduleType === 'cron'){
          const cronExpr = (fd.get('cronExpr') || '').trim();
          if(!cronExpr) return alert('Enter a cron expression');
          payload.schedule = { type: 'cron', cron: cronExpr };
        }

        const btn = form.querySelector('button');
        btn.disabled = true; btn.textContent = 'Scheduling...';
        try{
          await fetch(API + '/tasks', { method:'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          form.reset();
          updateControls();
          await refresh();
        }catch(err){
          console.error(err);
          alert('Failed to schedule task');
        }finally{ btn.disabled = false; btn.textContent = 'Schedule Task'; }
      });

      // handle task actions: complete (tick) and delete (cross)
      document.getElementById('tasks').addEventListener('click', async (e)=>{
        const btn = e.target.closest('button[data-id]');
        if(!btn) return;
        const id = btn.dataset.id;
        if(!id) return;
        const action = btn.dataset.action || 'delete';

        if(action === 'complete'){
          // optimistic UI: mark completed locally
          const li = btn.closest('.task-card');
          if(li){
            li.classList.add('completed');
            // update chip text if present
            const chip = li.querySelector('.chip'); if(chip) chip.textContent = 'done';
          }

          btn.disabled = true;
          const prevText = btn.textContent;
          btn.textContent = '✔';
          try{
            const res = await fetch(API + '/tasks/' + encodeURIComponent(id) + '/complete', { method: 'POST' });
            if(!res.ok){
              const txt = await res.text().catch(()=>'<no body>');
              console.error('complete failed', res.status, txt);
              showToast('Failed to mark task complete: ' + res.status + '\n' + txt, 'error');
              // revert UI
              if(li){ li.classList.remove('completed'); const chip2 = li.querySelector('.chip'); if(chip2) chip2.textContent = 'scheduled'; }
              await refresh();
            } else {
              // success — update UI with server response
              const updated = await res.json().catch(()=>null);
              if(updated && li){ const meta = li.querySelector('.meta'); if(meta) meta.textContent = (updated.executedAt ? 'executed ' + new Date(updated.executedAt).toLocaleString() : meta.textContent); }
            }
          }catch(err){
            console.error('complete failed', err);
            showToast('Failed to mark task complete (network): ' + (err && err.message), 'error');
            if(li) li.classList.remove('completed');
            await refresh();
          }finally{
            btn.disabled = false; try{ btn.textContent = prevText; }catch(e){}
          }

          return;
        }

        // default: delete action
        // provide immediate feedback and prevent double clicks
        btn.disabled = true;
        const prevText = btn.textContent;
        btn.textContent = 'Deleting...';

        const li = btn.closest('.task-card');
        if(li){
          li.classList.add('removing');
          // wait for animation to finish (gentle UX)
          await new Promise(r => setTimeout(r, 260));
        }

        try{
          const res = await fetch(API + '/tasks/' + encodeURIComponent(id), { method:'DELETE' });
          if(!res.ok){
            const txt = await res.text().catch(()=>'<no body>');
            console.error('delete failed', res.status, txt);
            showToast('Failed to delete task: ' + res.status + '\n' + txt, 'error');
            // re-render to restore the item if deletion failed
            await refresh();
            return;
          }
        }catch(err){
          console.error('delete failed', err);
          showToast('Failed to delete task (network): ' + (err && err.message), 'error');
        }finally{
          btn.disabled = false;
          try{ btn.textContent = prevText; }catch(e){}
        }

        // refresh list after deletion
        await refresh();
      });

      // initial load + polling
      (async function(){
        await loadLists();
        // request permission for notifications (best-effort)
        requestNotificationPermission().then(ok=>{ if(!ok) console.log('notifications not granted'); });
        refresh();
        // poll less frequently and avoid overlapping requests
        setInterval(refresh, 15000);
        // also run notification scheduler every 60s to catch new tasks
        setInterval(async ()=>{ try{ const tasks = await fetchTasks(); scheduleUpcomingNotifications(tasks); }catch(e){} }, 60 * 1000);
      })();
    </script>
  </body>
</html>
